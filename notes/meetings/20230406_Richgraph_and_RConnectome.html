<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.299">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Stefano Rapisarda">
<meta name="dcterms.date" content="2023-04-06">
<meta name="keywords" content="Noede, RichGraph, Metadata, Researchers Connectome project, FAIR research software">

<title>Meeting with Rik Janssen on Richgraph and RConnectome</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="20230406_Richgraph_and_RConnectome_files/libs/clipboard/clipboard.min.js"></script>
<script src="20230406_Richgraph_and_RConnectome_files/libs/quarto-html/quarto.js"></script>
<script src="20230406_Richgraph_and_RConnectome_files/libs/quarto-html/popper.min.js"></script>
<script src="20230406_Richgraph_and_RConnectome_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="20230406_Richgraph_and_RConnectome_files/libs/quarto-html/anchor.min.js"></script>
<link href="20230406_Richgraph_and_RConnectome_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="20230406_Richgraph_and_RConnectome_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="20230406_Richgraph_and_RConnectome_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="20230406_Richgraph_and_RConnectome_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="20230406_Richgraph_and_RConnectome_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#motivation" id="toc-motivation" class="nav-link active" data-scroll-target="#motivation">Motivation</a></li>
  <li><a href="#what-we-discussed" id="toc-what-we-discussed" class="nav-link" data-scroll-target="#what-we-discussed">What we discussed</a></li>
  <li><a href="#meeting-outcomes" id="toc-meeting-outcomes" class="nav-link" data-scroll-target="#meeting-outcomes">Meeting outcome(s)</a>
  <ul class="collapse">
  <li><a href="#todo" id="toc-todo" class="nav-link" data-scroll-target="#todo">TODO:</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Meeting with Rik Janssen on Richgraph and RConnectome</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Stefano Rapisarda </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 6, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<p>The meeting follows a presentation made by Erik on the 30th of March 2023 (Demonstratielunch Ricgraph - Research in context graph). The presentation was in dutch, but the slides were in English. The language did not matter much in that context as graphs are all about graphics. Rik presented a software (Ricgraph) to store, access, and visualize information related to researchers working at the Utrecht University (and, maybe, beyond). I’ve been always interested on graphs both because of my taking note application and the more recent concept of a Researchers Connectome, so I decided to meet Rik in person to know a bit more (in English) about his work.</p>
</section>
<section id="what-we-discussed" class="level2">
<h2 class="anchored" data-anchor-id="what-we-discussed">What we discussed</h2>
<ul>
<li>I asked Rik about <strong>his position at the University</strong>. Like in many other cases it is not very well defined. He mentioned he does a job that sounds very similar to what Research Software Engineers do. According to his personal page he is a Business analyst and a Consultant ICT, but, again, it seems that here what you are supposed to do does not always collide with what you do at the end of the day;</li>
<li>I asked Rik <strong>how the all graph project started</strong> and he mentioned the FAIR Research IT program at the UU. There is a lot of documentation about this FAIR Research IT program but it’s mainly in Dutch (thing that I find no much FAIR). Anyhow, it seems that Ricgraph is (or it is considered) an outcome of this program born by the personal initiative of Rik. Rik told me that he was frustrated by continuous discussions on clustering research IDs at Surf and at the faculty, so that he decided to make an implementation. He used graphs and and several databases, including the UU researcher database, Pure data, ORCID, and … (he mentioned something else, but I guess I can find information on the website);</li>
<li>I asked him about the <strong>algorithm</strong> that allows to find the shortest path between two nodes, but he himself did not know. It seems he used a python packages, or an “engine” (whatever it may mean in this context) for the graph database and adopted the algorithm in there. I repeated to him the objections I heard at the Software Engineer table about the research speed compared to normal table data, but he was pretty sure that even without knowing the initial node, the graph database would be still faster. He also mentioned that this may change at a certain point depending on the number of nodes;</li>
<li>We discussed about the information visualized by Ricgraph, he said that the main problem is when people mislabel information or have, for example, two ORCID accounts. In that case he decided to throw away the nodes, but that in principle you can keep all the information and write an algorithm to identify the “ourliers”. In other words, Ricgraph works with the big assumption that scientists have a unique identifier, they correctly put all their scientific products online, and they did not mislabel info;</li>
<li>Rik then asked me about why was I interested in Ricgraph and I went on describing the concept of Researchers Connectome;</li>
</ul>
</section>
<section id="meeting-outcomes" class="level2">
<h2 class="anchored" data-anchor-id="meeting-outcomes">Meeting outcome(s)</h2>
<ul>
<li>The first outcomes is that the idea of the Connectome is not a bad idea (unless he just pretended to be nice). He mentioned that the first problem would be how to extract the “skill” information. Where should I start this information from? I proporsed, naivey, with a campaign, but he said that basically that could never happen. Then from where? Personal pages of the researchers? Another solution would be accessing via Ricgraph the DOIs associated with the researchers, reading information or meta data from these products and trying to extract the skills. About extracting this information from metadata, he mentioned to talk to Otto;</li>
<li>Another thing it came out is that, in order to be really useful, the ORCID account doen’t need to be only created, but also USED. Only in this way algorithms can trace or reconstruct the scientific production of a researcher and creating those nice visualizations. For example he mentioned that one of the main problem is mislabeling in YODA, people just misspelling their identifier in YODA;</li>
</ul>
<section id="todo" class="level3">
<h3 class="anchored" data-anchor-id="todo">TODO:</h3>
<ul class="task-list">
<li><input type="checkbox">Talk to Jonathan about the project;</li>
<li><input type="checkbox">Make your profile page public;</li>
<li><input type="checkbox">Play a bit with Ricgraph;</li>
<li><input type="checkbox">Fix another appointment with Otto;</li>
<li><input type="checkbox">Ask Jonathan about the FAIR Research IT program and what’s the difference with the FAIR program he is in;</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>